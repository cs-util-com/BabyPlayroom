// /public/app.js\nimport { animals, EFFECT_IDS, PASTELS } from \'./sounds.js\';\n\nconst MAX_ANIMALS = 10;\nconst SPAWN_INTERVAL = 10000; // 10 seconds\nconst PARENT_MENU_SWIPE_TIMEOUT = 3000; // 3 seconds to swipe to padlock\nconst DEFAULT_SESSION_DURATION = 10 * 60 * 1000; // 10 minutes\n\nconst gameContainer = document.getElementById(\'game-container\');\nconst parentMenuButton = document.getElementById(\'parent-menu-button\');\nconst overlay = document.getElementById(\'overlay\');\nconst padlockTarget = document.getElementById(\'padlock-target\');\nconst settingsPanel = document.getElementById(\'settings\');\nconst volumeSlider = document.getElementById(\'vol\');\nconst sessionButtons = document.querySelectorAll(\'#settings .btn-row button\');\nconst sessionToast = document.getElementById(\'session-toast\');\n\nlet activeAnimals = [];\nlet spawnTimerId = null;\nlet sessionTimerId = null;\nlet currentSessionDuration = DEFAULT_SESSION_DURATION;\nlet parentMenuSwipeTimer = null;\nlet isSettingsUnlocked = false;\n\n// --- Sound Management (Howler.js) ---\n// Global Howler instance is available as `Howler`\nHowler.volume(0.7); // Default volume from README\n\nfunction playSound(src, isHtml5 = true) {\n  if (!src) return;\n  const sound = new Howl({\n    src: [src],\n    html5: isHtml5, // Bypass CORS for BBC sounds as per README\n    volume: Howler.volume() // Use global volume\n  });\n  sound.play();\n}\n\n// --- Animal Spawning & Management ---\nfunction getRandomInt(min, max) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\nfunction spawnAnimal() {\n  if (activeAnimals.length >= MAX_ANIMALS) return;\n\n  const animalData = animals[getRandomInt(0, animals.length - 1)];\n  const animalElement = document.createElement(\'div\');\n  animalElement.classList.add(\'animal\');\n  animalElement.textContent = animalData.emoji;\n  animalElement.dataset.name = animalData.name; // For debugging or future use\n\n  // Random size\n  const size = getRandomInt(animalData.size[0], animalData.size[1]);\n  animalElement.style.width = `${size}px`;\n  animalElement.style.height = `${size}px`;\n  animalElement.style.fontSize = `${size * 0.8}px`; // Adjust emoji size within div\n\n  // Random initial position (ensure it\'s within viewport)\n  const x = getRandomInt(0, gameContainer.clientWidth - size);\n  const y = getRandomInt(0, gameContainer.clientHeight - size);\n  animalElement.style.left = `${x}px`;\n  animalElement.style.top = `${y}px`;\n\n  // Store initial transform for wander animation\n  animalElement.style.setProperty(\'--x0\', `${x}px`);\n  animalElement.style.setProperty(\'--y0\', `${y}px`);\n  animalElement.style.setProperty(\'--scale\', `1`); // Initial scale\n\n  // Random despawn effect\n  animalElement.dataset.despawnEffect = EFFECT_IDS[getRandomInt(0, EFFECT_IDS.length - 1)];\n  animalElement.dataset.soundTap = animalData.soundTap;\n  animalElement.dataset.soundAppear = animalData.soundAppear;\n\n  // Add to DOM and active list\n  gameContainer.appendChild(animalElement);\n  activeAnimals.push(animalElement);\n\n  playSound(animalData.soundAppear);\n  resetSpawnTimer();\n  setupWanderAnimation(animalElement);\n\n  animalElement.addEventListener(\'click\', handleAnimalTap);\n  animalElement.addEventListener(\'touchstart\', handleAnimalTap, { passive: true });\n}\n\nfunction handleAnimalTap(event) {\n  const animalElement = event.currentTarget;\n  if (animalElement.classList.contains(\'despawning\')) return; // Already tapped\n\n  animalElement.classList.add(\'despawning\'); // Mark as despawning\n  playSound(animalElement.dataset.soundTap);\n\n  // Apply despawn effect\n  const effect = animalElement.dataset.despawnEffect;\n  animalElement.classList.add(effect);\n  animalElement.style.animation = \'none\'; // Stop wander\n  requestAnimationFrame(() => { // Ensure wander is stopped before applying new animation\n    animalElement.style.animation = \'\'; // Clear it to re-apply class-based animation\n    animalElement.classList.add(effect); // Re-add to trigger\n  });\n\n\n  // Remove after animation (1s as per spec)\n  setTimeout(() => {\n    if (animalElement.parentNode) {\n      animalElement.parentNode.removeChild(animalElement);\n    }\n    activeAnimals = activeAnimals.filter(el => el !== animalElement);\n  }, 1000); // Matches despawn animation durations\n\n  resetSpawnTimer();\n}\n\nfunction resetSpawnTimer() {\n  clearTimeout(spawnTimerId);\n  spawnTimerId = setTimeout(spawnAnimal, SPAWN_INTERVAL);\n}\n\n// --- Motion & Wrap-around Logic ---\nfunction setupWanderAnimation(element) {\n  const updateWander = () => {\n    if (!document.body.contains(element) || element.classList.contains(\'despawning\')) {\n      return; // Stop if element is removed or despawning\n    }\n\n    const baseMove = Math.min(window.innerWidth, window.innerHeight) * 0.20; // 20vw/vh equivalent\n\n    // Current transform values are needed to make deltas relative\n    // However, directly reading element.style.transform is tricky with CSS animations.\n    // Instead, we\'ll set new absolute targets for the keyframes.\n    // The wrap-around logic will handle jumps.\n\n    const currentRect = element.getBoundingClientRect();\n    let currentX = parseFloat(element.style.left || \'0\');\n    let currentY = parseFloat(element.style.top || \'0\');\n\n    // Define new target coordinates for the animation keyframes\n    // These are absolute positions, not deltas from current animated state.\n    for (let i = 1; i <= 4; i++) {\n      let nextX = currentX + getRandomInt(-baseMove, baseMove);\n      let nextY = currentY + getRandomInt(-baseMove, baseMove);\n\n      // Simple boundary check for targets - can be improved with projection\n      nextX = Math.max(0, Math.min(nextX, gameContainer.clientWidth - element.offsetWidth));\n      nextY = Math.max(0, Math.min(nextY, gameContainer.clientHeight - element.offsetHeight));\n\n      element.style.setProperty(`--x${i}`, `${nextX}px`);\n      element.style.setProperty(`--y${i}`, `${nextY}px`);\n    }\n    // The 0% and 100% keyframes use --x0, --y0 and --x4, --y4 respectively.\n    // We need to update --x0 and --y0 to the current position for smooth transition if animation restarts.\n    element.style.setProperty(\'--x0\', `${currentX}px`);\n    element.style.setProperty(\'--y0\', `${currentY}px`);\n\n    // Wrap-around logic\n    if (currentRect.right < 0) element.style.left = `${gameContainer.clientWidth - 1}px`; // Came from left\n    if (currentRect.left > gameContainer.clientWidth) element.style.left = `${1 - currentRect.width}px`; // Came from right\n    if (currentRect.bottom < 0) element.style.top = `${gameContainer.clientHeight - 1}px`; // Came from top\n    if (currentRect.top > gameContainer.clientHeight) element.style.top = `${1 - currentRect.height}px`; // Came from bottom\n  };\n\n  // Initial setup for wander variables\n  updateWander(); \n  // Update animation variables on each iteration\n  element.addEventListener(\'animationiteration\', updateWander);\n}\n\n// --- Background Changer ---\nfunction applyRandomBackground() {\n  const [c1, c2] = crypto.getRandomValues(new Uint32Array(2))\n      .map(n => PASTELS[n % PASTELS.length]);\n  document.documentElement.style.setProperty(\'--bg1\', c1);\n  document.documentElement.style.setProperty(\'--bg2\', c2);\n}\nsetInterval(applyRandomBackground, SPAWN_INTERVAL); // Change with spawn tick\n\n// --- Fullscreen & Orientation Lock ---\nasync function requestFull() {\n  try {\n    if (document.documentElement.requestFullscreen) {\n      await document.documentElement.requestFullscreen();\n    } else if (document.documentElement.mozRequestFullScreen) { /* Firefox */\n      await document.documentElement.mozRequestFullScreen();\n    } else if (document.documentElement.webkitRequestFullscreen) { /* Chrome, Safari & Opera */\n      await document.documentElement.webkitRequestFullscreen();\n    } else if (document.documentElement.msRequestFullscreen) { /* IE/Edge */\n      await document.documentElement.msRequestFullscreen();\n    }\n\n    if (screen.orientation && screen.orientation.lock) {\n      await screen.orientation.lock(\'landscape\').catch(e => console.warn(\'Orientation lock failed\', e));\n    }\n  } catch (e) {\n    console.warn(\'Fullscreen request failed\', e);\n  }\n}\n\n// --- Parent Menu Interaction ---\nfunction showOverlay(showPadlock = true) {\n  overlay.hidden = false;\n  requestAnimationFrame(() => { // Ensure display:flex is applied before transition\n    overlay.classList.add(\'visible\');\n  });\n  settingsPanel.hidden = true; // Always hide settings first\n  settingsPanel.classList.remove(\'unlocked\');\n  padlockTarget.hidden = !showPadlock;\n  isSettingsUnlocked = false;\n\n  if (showPadlock) {\n    clearTimeout(parentMenuSwipeTimer);\n    parentMenuSwipeTimer = setTimeout(() => {\n      if (!isSettingsUnlocked) hideOverlay();\n    }, PARENT_MENU_SWIPE_TIMEOUT);\n  }\n}\n\nfunction hideOverlay() {\n  overlay.classList.remove(\'visible\');\n  // Listen for transition end to set hidden attribute for accessibility and performance\n  overlay.addEventListener(\'transitionend\', () => {\n    overlay.hidden = true;\n  }, { once: true });\n  clearTimeout(parentMenuSwipeTimer);\n}\n\nfunction unlockSettings() {\n  isSettingsUnlocked = true;\n  padlockTarget.hidden = true;\n  settingsPanel.hidden = false;\n  requestAnimationFrame(() => { // Ensure display block before transition\n    settingsPanel.classList.add(\'unlocked\');\n  });\n  clearTimeout(parentMenuSwipeTimer); // Don\'t auto-hide if unlocked\n}\n\nparentMenuButton.addEventListener(\'click\', () => showOverlay());\nparentMenuButton.addEventListener(\'touchstart\', (e) => { e.preventDefault(); showOverlay(); }, { passive: false });\n\n// Simple distance check for padlock swipe (using pointermove for broader compatibility)\n// More robust would be full gesture detection.\npadlockTarget.addEventListener(\'pointerdown\', (e) => {\n  // For a real swipe, you\'d track pointermove and check distance/direction.\n  // Here, we simplify: a click/tap on padlock when it\'s visible means success.\n  if (!padlockTarget.hidden) {\n    unlockSettings();\n  }\n});\n\n// Close overlay if clicking outside settings panel (but not on padlock)\noverlay.addEventListener(\'click\', (event) => {\n  if (event.target === overlay && !settingsPanel.hidden) { // Clicked on backdrop while settings are open\n    hideOverlay();\n  }\ else if (event.target === overlay && !padlockTarget.hidden) { // Clicked on backdrop while padlock is open\n     hideOverlay();\n  }\n});\n\n\n// --- Settings Panel Logic ---\nvolumeSlider.addEventListener(\'input\', (e) => {\n  Howler.volume(parseFloat(e.target.value) / 100);\n});\n\nsessionButtons.forEach(button => {\n  button.addEventListener(\'click\', () => {\n    sessionButtons.forEach(btn => btn.classList.remove(\'active\'));\n    button.classList.add(\'active\');\n    currentSessionDuration = parseInt(button.dataset.min) * 60 * 1000;\n    startSessionTimer();\n    hideOverlay(); // Hide menu after selection\n    // Potentially show a small confirmation\n  });\n});\n\n// --- Session Timer & Toast ---\nfunction startSessionTimer() {\n  clearTimeout(sessionTimerId);\n  sessionToast.hidden = true;\n  sessionTimerId = setTimeout(() => {\n    sessionToast.textContent = \"Time for a cuddle!\"; // As per README\n    sessionToast.hidden = false;\n    // Optionally pause the game or show a more prominent overlay\n    clearTimeout(spawnTimerId); // Stop spawning new animals\n    // Auto-hide toast after a few seconds\n    setTimeout(() => sessionToast.hidden = true, 5000);\n  }, currentSessionDuration);\n}\n\n// --- Accessibility & Safety ---\nfunction checkReducedMotion() {\n  const mediaQuery = window.matchMedia(\'(prefers-reduced-motion: reduce)\');\n  if (mediaQuery.matches) {\n    // JS can also stop or alter animations if CSS isn\'t enough\n    // For now, CSS handles it via @media query\n    console.log(\"Reduced motion is preferred. Animations will be simpler.\");\n  }\n}\n\n// --- Initialization ---\nfunction initGame() {\n  console.log(\"Baby Playroom Initializing...\");\n  // Initial background\n  applyRandomBackground();\n\n  // Initial spawn\n  for (let i = 0; i < 3; i++) { // Start with a few animals\n    spawnAnimal();\n  }\n  resetSpawnTimer(); // Start the regular spawn cycle\n\n  // Session timer\n  startSessionTimer();\n\n  // Fullscreen on first user gesture (e.g. tap to start button - not implemented here yet)\n  // For now, we can try to trigger it on a generic first tap if desired, or a dedicated button.\n  // document.body.addEventListener(\'click\', requestFull, { once: true });\n  // A better approach is a dedicated \"Start\" button that calls requestFull()\n\n  // Set initial volume display based on Howler's actual volume\n  volumeSlider.value = Howler.volume() * 100;\n\n  checkReducedMotion();\n  window.matchMedia(\'(prefers-reduced-motion: reduce)\').addEventListener(\'change\', checkReducedMotion);\n\n  console.log(\"Game Initialized. Tap animals or \'X\' for parent menu.\");\n}\n\n// Wait for DOM and Howler to be ready\nif (document.readyState === \'loading\') {\n  document.addEventListener(\'DOMContentLoaded\', initGame);\n} else {\n  initGame();\n}\n\n// Optional: Service Worker Registration (if sw.js is in the root)\nif (\'serviceWorker\' in navigator && window.location.protocol === \'https:\') { // Or localhost\n  navigator.serviceWorker.register(\'/sw.js\') // Ensure sw.js is at the root or adjust path\n    .then(registration => {\n      console.log(\'ServiceWorker registration successful with scope: \', registration.scope);\n    })\n    .catch(error => {\n      console.log(\'ServiceWorker registration failed: \', error);\n    });\n}\n
